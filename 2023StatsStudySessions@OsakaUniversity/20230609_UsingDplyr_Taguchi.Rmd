---
title: "dplyr を使った分析前の準備 by 田口恵也"
author: "金山篤志"
date: "2023-06-09"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
---

# パッケージのインストールと読み込み

最初に、分析に必要なパッケージをインストールし、読み込みます。dplyrパッケージとggplot2パッケージを使用するため、以下のコードを実行します。

```{r, error=TRUE, include=TRUE}
# dplyrパッケージとggplot2パッケージをインストール
install.packages("dplyr")
install.packages("ggplot2")

# インストールしたパッケージを読み込む
library("dplyr")
library("ggplot2")
```

## データの準備

次に、分析のためのデータを準備します。今回は mpg データセットを使用します。mpgはRに組み込まれているデータセットで、自動車の燃費に関する情報が入っています。

```{r, error=TRUE, include=TRUE}
# mpgデータセットを読み込みます
data(mpg)
```

## データの確認

データを読み込んだ後、まずはデータの概要を確認しましょう。head関数を使うと、データの最初の6行を表示することができます。

```{r, error=TRUE, include=TRUE}
# mpgデータセットの最初の6行を表示します
head(mpg)
```

mpg データは、自動車の燃費に関する情報を持つデータセットです。データセットの各列には以下のような情報が含まれています。

- manufacturer: 製造メーカーの名前
- model: モデル名
- displ: 排気量（単位: L）
- year: 製造年
- cyl: シリンダー数

## データの加工

次に、データを分析に適した形に加工します。ここでは、dplyrパッケージの関数を使ってデータを絞り込み、新しい列を作成します。

```{r, error=TRUE, include=TRUE}
# mpgデータを絞り込み、新しい列を作成
mpg_filtered <- mpg %>%
  select(manufacturer, model, displ, year, cyl) %>%  # 列の絞り込み
  filter(manufacturer == "audi") %>%  # 行の絞り込み
  mutate(century = ceiling(year / 100)) # 新しい列を作成
```

```{r, error=TRUE, include=TRUE}
head(mpg_filtered)  # 加工後のデータを表示
```

```{r, error=TRUE, include=TRUE}
# 加工後のデータセットmpg_filteredの最初の6行を表示します。
head(mpg_filtered)
```

上記のコードでは、mpg データから特定の列（manufacturer、model、displ、year、cyl）を選択し、manufacturer 列が "audi" のデータを抽出しています。さらに、year 列を使って新しい列 century を作成しています。加工後のデータを mpg_filtered という新しいオブジェクトに格納し、表示しています。

- select(): 条件に合わせて特定の列を抽出する関数です。ここでは、mpg データから manufacturer、model、displ、year、cyl 列を選択しています。
- filter(): 条件に合わせて特定の行を抽出する関数です。ここでは、manufacturer 列が "audi" のデータを抽出しています。
- mutate(): 既存のデータに新しい列を追加する関数です。ここでは、year 列を使って新しい列 century を作成しています。

## エラーの確認

R Markdownでは、エラーが出ても読み込むことができ、再生マークをクリックしてRコードの出力結果を表示することができます。以下のコードでエラーのテストを行います。

```{r, error=TRUE, include=TRUE}
# エラーを発生させるコード例
unknown_function()
```

上記のコードでは、unknown_function() という存在しない関数を呼び出してエラーを発生させています。

## 応用問題

以下のコードで応用問題の解答を表示します。

```{r, error=TRUE, include=TRUE}
# 応用問題の解答
mpg_solution <- mpg %>%
  select(manufacturer, model, year, class) %>%  # 列の絞り込み
  arrange(desc(year)) %>%  # year列を降順に並び替え
  select(class, manufacturer, year, model)  # 列の並び替え
```

```{r, error=TRUE, include=TRUE}
head(mpg_solution)  # 解答を表示
```

このコードでは、まずmpgデータセットからmanufacturer、model、year、classの列を選択しています。その後、year列を降順に並び替え（最新の年から始まるように）し、最終的に各列を指定した順序に再配置しています。

- arrange(): 列の値を昇順または降順に並び替える関数です。ここでは、desc() 関数を使って year 列を降順に並び替えています。

## dplyrの便利な関数：group_by()とfull_join()

### group_by()

`group_by()`は、データを特定の条件に基づいてグループ化する関数です。具体的な使用例として、都市ごとの人口の平均を求めるケースを考えてみましょう。

まずは、都市と人口を含むサンプルデータフレームを作成します。

```{r, error=TRUE, include=TRUE}
# サンプルデータフレームの作成
df <- data.frame(
  city = c("東京", "大阪", "東京", "大阪", "東京"),
  population = c(1000, 2000, 1500, 2500, 1300)
)

print(df)
```

次にgroup_by(city)を用いて都市ごとにデータをグループ化し、その後summarise()を使って平均値を求めます。

```{r, error=TRUE, include=TRUE}
df_grouped <- df %>%
  group_by(city) %>%
  summarise(avg_population = mean(population))

print(df_grouped)
```

この結果、都市ごとの人口の平均値を簡単に算出することができました。

- full_join()は、2つのデータフレームを一つに結合する関数です。この結合方法は全結合（full join）と呼ばれ、2つのデータフレームの全ての行を結合します。この時、どちらか一方のデータフレームにしか存在しない行もNAとして保持されます。

まずは、2つのサンプルデータフレームを作成します。

```{r, error=TRUE, include=TRUE}
# サンプルデータフレームの作成
df1 <- data.frame(
  city = c("東京", "大阪", "福岡"),
  population = c(1000, 2000, 1500)
)

df2 <- data.frame(
  city = c("大阪", "福岡", "札幌"),
  area = c(223.00, 340.60, 1121.12)
)

print(df1)
print(df2)
```

次にfull_join()を使って、これらのデータフレームを結合します。

```{r, error=TRUE, include=TRUE}
df_joined <- df1 %>%
  full_join(df2, by = "city")

print(df_joined)
```

この結果、両方のデータフレームの情報を統合することができました。なお、"東京"と"札幌"については片方のデータフレームにしか存在しないため、対応する値がNAとなっています。

## データセットの形

データは主にワイド形式とロング形式の2つの形式で表されます：

- ワイド形式：各観測値が行、各変数が列として配置される形式。時間経過に伴う複数の測定値などはこの形式で表されます。
- ロング形式：各観測値が行として配置され、変数が列として配置される形式。一つの列には同じ種類の値（例えば全てが体重）が入ります。

ワイド形式のデータをロング形式に、またその逆に変換するためには、tidyrパッケージのpivot_longer()とpivot_wider()を使用します。

まず、ワイド形式のデータを作成します。

```{r, error=TRUE, include=TRUE}
# ワイド形式のデータフレーム
df_wide <- data.frame(
  id = c(1, 2),
  weight_2001 = c(60, 55),
  weight_2002 = c(62, 58),
  weight_2003 = c(63, 59)
)

print(df_wide)
```

このデータフレームをロング形式に変換するためには、tidyverseのpivot_longer()を用います。

```{r, error=TRUE, include=TRUE}
# tidyverseの読み込み
library(tidyverse)

# ワイド形式のデータフレーム
df_wide <- data.frame(
  id = c(1, 2),
  weight_2001 = c(60, 55),
  weight_2002 = c(62, 58),
  weight_2003 = c(63, 59)
)

# pivot_longerを利用してロング形式に変換
df_long <- df_wide %>%
  pivot_longer(
    cols = starts_with("weight"),
    names_to = "year",
    values_to = "weight"
  )

# 結果の確認
print(df_long)
```

この結果、ワイド形式のデータがロング形式に変換されました。全ての体重の観測値がweight列に、それぞれの観測値がどの年に対応するのかを示す情報がyear列に保存されています。

逆に、ロング形式のデータをワイド形式に変換するには、pivot_wider()を用います。

```{r, error=TRUE, include=TRUE}
# ロング形式のデータフレームdf_longを、pivot_wider()関数を使ってワイド形式に変換します。
# names_from = yearは、新たに列名として使うデータが格納されている列を指定しています。
# values_from = weightは、新たに値として使うデータが格納されている列を指定しています。
df_wide_again <- df_long %>%
  pivot_wider(
    names_from = year,
    values_from = weight
  )

# 変換後のワイド形式のデータフレームを確認します。
print(df_wide_again)
```

この結果、ロング形式のデータが元のワイド形式に戻されました。

このように、pivot_longer()とpivot_wider()は、データ形状の変換に非常に便利なツールです。これらを使えば、データの視覚化やモデリングのために最適な形状にデータを変換することができます。

以上で、dplyrとtidyrの主な関数の紹介と使用例を終わります。更に詳細な使用方法や他の関数については、以下の参考ページやチートシートをご覧ください：

参考ページ：
1. [dplyr wiki](http://sugiura-ken.org/wiki/wiki.cgi/exp?page=dplyr)
2. [dplyr パッケージによるデータ操作と集計](https://stats.biopapyrus.jp/r/tidyverse/dplyr.html)
3. [R/RStudio入門 列選択](https://kazutan.github.io/JSSP2018_spring/data_handling.html#列選択)
4. [データ操作の日本語チートシート](https://raw.githubusercontent.com/rstudio/cheatsheets/main/translations/japanese/data-wrangling_ja.pdf)

をご参照ください。